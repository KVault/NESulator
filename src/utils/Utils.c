#include "Utils.h"

int bit_test(byte b, byte bitPos) {
	byte bitSet = (b >> (bitPos));
	return (bitSet & 1);
}

void bit_set(byte *b, byte bitPos) {
	*b |= 1UL << bitPos;
}

void bit_clear(byte *b, byte bitPos) {
	*b &= ~(1UL << bitPos);
}

void bit_val(byte *b, byte bitPos, int value) {
	(value) ? bit_set(b, bitPos) : bit_clear(b, bitPos);
}

/** from here:
 * https://stackoverflow.com/questions/4439078/how-do-you-set-only-certain-bits-of-a-byte-in-c-without-affecting-the-rest
 * value = (value & ~mask) | (newvalue & mask);
 */
byte byte_mask(byte source, byte mask, byte value) {
	return (source & ~mask) | (value & mask);
}

/** from here:
 * https://stackoverflow.com/questions/4439078/how-do-you-set-only-certain-bits-of-a-byte-in-c-without-affecting-the-rest
 * value = (value & ~mask) | (newvalue & mask);
 */
word word_mask(word source, word mask, word value) {
	return (source & ~mask) | (value & mask);
}

const colour  COLOUR_PALETTE[] = {
		{0x75, 0x75, 0x75}, //00
		{0x27, 0x1B, 0x8F}, //01
		{0x00, 0x00, 0xAB}, //02
		{0x47, 0x00, 0x9F}, //03
		{0x8F, 0x00, 0x77}, //04
		{0xAB, 0x00, 0x13}, //05
		{0xA7, 0x00, 0x00}, //06
		{0x7F, 0x0B, 0x00}, //07
		{0x43, 0x2F, 0x00}, //08
		{0x00, 0x47, 0x00}, //09
		{0x00, 0x51, 0x00}, //0A
		{0x00, 0x3F, 0x17}, //0B
		{0x1B, 0x3F, 0x5F}, //0C
		{0x00, 0x00, 0x00}, //0D
		{0x00, 0x00, 0x00}, //0E
		{0x00, 0x00, 0x00}, //0F
		{0xBC, 0xBC, 0xBC}, //10
		{0x00, 0x73, 0xEF}, //11
		{0x23, 0x3B, 0xEF}, //12
		{0x83, 0x00, 0xF3}, //13
		{0xBF, 0x00, 0xBF}, //14
		{0xE7, 0x00, 0x5B}, //15
		{0xDB, 0x2B, 0x00}, //16
		{0xCB, 0x4F, 0x0F}, //17
		{0x8B, 0x73, 0x00}, //18
		{0x00, 0x97, 0x00}, //19
		{0x00, 0xAB, 0x00}, //1A
		{0x00, 0x93, 0x3B}, //1B
		{0x00, 0x83, 0x8B}, //1C
		{0x00, 0x00, 0x00}, //1D
		{0x00, 0x00, 0x00}, //1E
		{0x00, 0x00, 0x00}, //1F
		{0xFF, 0xFF, 0xFF}, //20
		{0x3F, 0xBF, 0xFF}, //21
		{0x5F, 0x97, 0xFF}, //22
		{0xA7, 0x8B, 0xFD}, //23
		{0xF7, 0x7B, 0xFF}, //24
		{0xFF, 0x77, 0xB7}, //25
		{0xFF, 0x77, 0x63}, //26
		{0xFF, 0x9B, 0x3B}, //27
		{0xF3, 0xBF, 0x3F}, //28
		{0x83, 0xD3, 0x13}, //29
		{0x4F, 0xDF, 0x4B}, //2A
		{0x58, 0xF8, 0x98}, //2B
		{0x00, 0xEB, 0xDB}, //2C
		{0x00, 0x00, 0x00}, //2D
		{0x00, 0x00, 0x00}, //2E
		{0x00, 0x00, 0x00}, //2F
		{0xFF, 0xFF, 0xFF}, //30
		{0xAB, 0xE7, 0xFF}, //31
		{0xC7, 0xD7, 0xFF}, //32
		{0xD7, 0xCB, 0xFF}, //33
		{0xDD, 0xC7, 0xFF}, //34
		{0xFF, 0xC7, 0xDB}, //35
		{0xFF, 0xBF, 0xB3}, //36
		{0xFF, 0xDB, 0xAB}, //37
		{0xFF, 0xE7, 0xA3}, //38
		{0xE3, 0xFF, 0xA3}, //39
		{0xAB, 0xF3, 0xBF}, //3A
		{0xB3, 0xFF, 0xCF}, //3B
		{0x9F, 0xFF, 0xF3}, //3C
		{0x00, 0x00, 0x00}, //3D
		{0x00, 0x00, 0x00}, //3E
		{0x00, 0x00, 0x00}, //3F
};

uint encode_as_RGBA(colour colour){
	int rgba = 0xff << (8 * 3);//Shift 3 bytes to the left (0xff000000)
	rgba += (colour.B << (8 * 2));//Shift 2 bytes to the left (0xffBB0000)
	rgba += (colour.G << 8); //Shift a byte to the left (0xffBBGG00)
	rgba += (colour.R); //0xffBBGGRR

	return (uint)rgba;
}
