#include "Utils.h"
#include "log.h"
#include "../cpu.h"
#include "../memory.h"
#include "../ppu.h"

int bit_test(byte b, byte bitPos) {
	byte bitSet = (b >> (bitPos));
	return (bitSet & 1);
}

void bit_set(byte *b, byte bitPos) {
	*b |= 1UL << bitPos;
}

void bit_clear(byte *b, byte bitPos) {
	*b &= ~(1UL << bitPos);
}

void bit_val(byte *b, byte bitPos, int value) {
	(value) ? bit_set(b, bitPos) : bit_clear(b, bitPos);
}

bool page_crossed(word addr1, word addr2){
	return (addr1 & 0xFF00) != (addr2 & 0xFF00);
}

byte mask_byte(byte original_value, byte mask, byte mask_value){
	return (original_value & ~mask) | (mask_value & mask);
}

word mask_word(word original_value, word mask, word mask_value){
	return (original_value & ~mask) | (mask_value & mask);
}


void log_instruction(int num_params, const char *mnemonic, ...) {
	log_debug("%02X %02X ", PC, currentOpcode);
	for (uint i = 1; i <= num_params; i++) {
		log_debug("%02X ", rmem_b(PC + i));
	}
	log_debug("\t");
	if (num_params == 0) {
		log_debug("\t");
	}
	va_list args;
	va_start(args, mnemonic);
	vlog(mnemonic, ConsoleDebug, FileDebug, args);
	va_end(args);
	log_debug("\t\t\t");
	log_debug("A:%02X X:%02X Y:%02X ", A, X, Y);

	//Now for the status register. A bit of dirty code but the logs will be much clearer
	log_debug("P:");
	log_debug(bit_test(P, flagN) ? "N" : "n");
	log_debug(bit_test(P, flagV) ? "V" : "c_vram");
	log_debug(bit_test(P, flagUnused) ? "U" : "u");
	log_debug(bit_test(P, flagB) ? "B" : "b");
	log_debug(bit_test(P, flagD) ? "D" : "d");
	log_debug(bit_test(P, flagI) ? "I" : "i");
	log_debug(bit_test(P, flagZ) ? "Z" : "z");
	log_debug(bit_test(P, flagC) ? "C" : "c");

	log_debug(" ");

	//And the rest of the registers
	log_debug("SP:%02X CPU_CYC:%d", SP, cpu_cyclesThisSec);
	log_debug(" ");
	log_debug("PPU_CYC:%3d", current_cycle_scanline);
	log_debug("\n");
}


const colour  COLOUR_PALETTE[] = {
		{0x75, 0x75, 0x75}, //00
		{0x27, 0x1B, 0x8F}, //01
		{0x00, 0x00, 0xAB}, //02
		{0x47, 0x00, 0x9F}, //03
		{0x8F, 0x00, 0x77}, //04
		{0xAB, 0x00, 0x13}, //05
		{0xA7, 0x00, 0x00}, //06
		{0x7F, 0x0B, 0x00}, //07
		{0x43, 0x2F, 0x00}, //08
		{0x00, 0x47, 0x00}, //09
		{0x00, 0x51, 0x00}, //0A
		{0x00, 0x3F, 0x17}, //0B
		{0x1B, 0x3F, 0x5F}, //0C
		{0x00, 0x00, 0x00}, //0D
		{0x00, 0x00, 0x00}, //0E
		{0x00, 0x00, 0x00}, //0F
		{0xBC, 0xBC, 0xBC}, //10
		{0x00, 0x73, 0xEF}, //11
		{0x23, 0x3B, 0xEF}, //12
		{0x83, 0x00, 0xF3}, //13
		{0xBF, 0x00, 0xBF}, //14
		{0xE7, 0x00, 0x5B}, //15
		{0xDB, 0x2B, 0x00}, //16
		{0xCB, 0x4F, 0x0F}, //17
		{0x8B, 0x73, 0x00}, //18
		{0x00, 0x97, 0x00}, //19
		{0x00, 0xAB, 0x00}, //1A
		{0x00, 0x93, 0x3B}, //1B
		{0x00, 0x83, 0x8B}, //1C
		{0x00, 0x00, 0x00}, //1D
		{0x00, 0x00, 0x00}, //1E
		{0x00, 0x00, 0x00}, //1F
		{0xFF, 0xFF, 0xFF}, //20
		{0x3F, 0xBF, 0xFF}, //21
		{0x5F, 0x97, 0xFF}, //22
		{0xA7, 0x8B, 0xFD}, //23
		{0xF7, 0x7B, 0xFF}, //24
		{0xFF, 0x77, 0xB7}, //25
		{0xFF, 0x77, 0x63}, //26
		{0xFF, 0x9B, 0x3B}, //27
		{0xF3, 0xBF, 0x3F}, //28
		{0x83, 0xD3, 0x13}, //29
		{0x4F, 0xDF, 0x4B}, //2A
		{0x58, 0xF8, 0x98}, //2B
		{0x00, 0xEB, 0xDB}, //2C
		{0x00, 0x00, 0x00}, //2D
		{0x00, 0x00, 0x00}, //2E
		{0x00, 0x00, 0x00}, //2F
		{0xFF, 0xFF, 0xFF}, //30
		{0xAB, 0xE7, 0xFF}, //31
		{0xC7, 0xD7, 0xFF}, //32
		{0xD7, 0xCB, 0xFF}, //33
		{0xDD, 0xC7, 0xFF}, //34
		{0xFF, 0xC7, 0xDB}, //35
		{0xFF, 0xBF, 0xB3}, //36
		{0xFF, 0xDB, 0xAB}, //37
		{0xFF, 0xE7, 0xA3}, //38
		{0xE3, 0xFF, 0xA3}, //39
		{0xAB, 0xF3, 0xBF}, //3A
		{0xB3, 0xFF, 0xCF}, //3B
		{0x9F, 0xFF, 0xF3}, //3C
		{0x00, 0x00, 0x00}, //3D
		{0x00, 0x00, 0x00}, //3E
		{0x00, 0x00, 0x00}, //3F
};

uint encode_as_RGBA(colour colour){
	int rgba = 0xff << (8 * 3);//Shift 3 bytes to the left (0xff000000)
	rgba += (colour.B << (8 * 2));//Shift 2 bytes to the left (0xffBB0000)
	rgba += (colour.G << 8); //Shift a byte to the left (0xffBBGG00)
	rgba += (colour.R); //0xffBBGGRR

	return (uint)rgba;
}
